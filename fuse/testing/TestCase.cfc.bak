/**
 * TestCase - Base class for xUnit-style test cases
 *
 * Provides lifecycle hooks (setup/teardown), test method discovery, and
 * assertion mixin for writing isolated, convention-based tests.
 *
 * USAGE EXAMPLES:
 *
 * Basic test case:
 *     component extends="fuse.testing.TestCase" {
 *         public function testUserCreation() {
 *             var user = new User(this.datasource);
 *             user.name = "John Doe";
 *             assertEqual("John Doe", user.name);
 *         }
 *     }
 *
 * With setup and teardown:
 *     component extends="fuse.testing.TestCase" {
 *         public function setup() {
 *             // Called before each test method
 *             variables.user = new User(this.datasource);
 *             variables.user.email = "test@example.com";
 *         }
 *
 *         public function teardown() {
 *             // Called after each test method
 *             structDelete(variables, "user");
 *         }
 *
 *         public function testEmailValidation() {
 *             assertTrue(variables.user.isValid());
 *         }
 *
 *         public function testSave() {
 *             assertTrue(variables.user.save());
 *         }
 *     }
 *
 * Using factories:
 *     var user = make("User", {email: "custom@test.com"});
 *     var admin = create("User", {}, ["admin"]);
 *
 * Using assertions (mixed in from Assertions.cfc):
 *     assertEqual(expected, actual);
 *     assertNotEqual(expected, actual);
 *     assertTrue(value);
 *     assertFalse(value);
 *     assertNull(value);
 *     assertNotNull(value);
 *     assertThrows(function() { user.save(); });
 *     assertCount(3, users);
 *     assertContains("admin", roles);
 *     assertNotContains("banned", roles);
 *     assertMatches("^\w+@", email);
 *     assertEmpty(array);
 *     assertNotEmpty(struct);
 *     assertInstanceOf("User", user);
 *     assertGreaterThan(0, total);
 *     assertLessThan(100, discount);
 *
 * Using database assertions:
 *     assertDatabaseHas("users", {email: "test@example.com"});
 *     assertDatabaseMissing("users", {email: "deleted@example.com"});
 *     assertDatabaseCount("users", 10);
 *
 * Using handler testing helpers:
 *     var request = makeRequest("GET", "/users", {page: 1});
 *     var response = handle(request);
 *     assertEqual(200, response.statusCode);
 *     assertContains("Users", response.body);
 *
 * Conventions:
 * - Test files end with Test.cfc (UserTest.cfc, PostTest.cfc)
 * - Test methods start with "test" prefix (testUserCreation, testValidation)
 * - setup() runs before each test method
 * - teardown() runs after each test method
 * - Each test runs in a database transaction that rolls back automatically
 */
component {

	/**
	 * Initialize TestCase
	 *
	 * @datasource Optional datasource name for database tests
	 * @return TestCase instance for chaining
	 */
	public function init(string datasource = "") {
		// Store datasource for test methods to access
		if (len(arguments.datasource)) {
			variables.datasource = arguments.datasource;
			this.datasource = arguments.datasource;
		}

		// Mix in assertion methods from Assertions.cfc
		mixinAssertions();

		// Mix in factory helper methods
		mixinFactoryHelpers();

		// Mix in handler testing helpers
		mixinHandlerHelpers();

		return this;
	}

	/**
	 * Setup lifecycle hook - override in subclasses
	 *
	 * Called before each test method. Use to prepare test state, create test data,
	 * or initialize variables needed by multiple tests.
	 */
	public void function setup() {
		// Empty default implementation - subclasses override
	}

	/**
	 * Teardown lifecycle hook - override in subclasses
	 *
	 * Called after each test method. Use to clean up test state, delete test data,
	 * or reset variables. Database changes are rolled back automatically.
	 */
	public void function teardown() {
		// Empty default implementation - subclasses override
	}

	/**
	 * Discover test methods using metadata introspection
	 *
	 * Finds all public methods starting with "test" prefix.
	 * Follows ActiveRecord.cfc pattern for metadata inspection.
	 *
	 * @return Array of test method name strings
	 */
	public array function getTestMethods() {
		var testMethods = [];
		var metadata = getMetadata(this);

		// Get functions from current component
		if (structKeyExists(metadata, "functions")) {
			for (var func in metadata.functions) {
				// Find public methods starting with "test"
				if (structKeyExists(func, "name") &&
					left(func.name, 4) == "test" &&
					(!structKeyExists(func, "access") || func.access == "public")) {
					arrayAppend(testMethods, func.name);
				}
			}
		}

		return testMethods;
	}

	// PRIVATE METHODS

	/**
	 * Mix in assertion methods from Assertions component
	 *
	 * Stores assertion instance and delegates assertion calls to it.
	 * Uses delegation pattern to preserve Assertions component's private method access.
	 */
	private void function mixinAssertions() {
		// Store assertions instance for delegation
		// Pass datasource for database assertions
		var ds = structKeyExists(variables, "datasource") ? variables.datasource : "";
		variables._assertions = new fuse.testing.Assertions(ds);

		// Create delegation methods for each assertion
		variables.assertEqual = function(required any expected, required any actual, string message = "") {
			variables._assertions.assertEqual(argumentCollection=arguments);
		};
		variables.assertNotEqual = function(required any expected, required any actual, string message = "") {
			variables._assertions.assertNotEqual(argumentCollection=arguments);
		};
		variables.assertTrue = function(required any value, string message = "") {
			variables._assertions.assertTrue(argumentCollection=arguments);
		};
		variables.assertFalse = function(required any value, string message = "") {
			variables._assertions.assertFalse(argumentCollection=arguments);
		};
		variables.assertNull = function(required any value, string message = "") {
			variables._assertions.assertNull(argumentCollection=arguments);
		};
		variables.assertNotNull = function(required any value, string message = "") {
			variables._assertions.assertNotNull(argumentCollection=arguments);
		};
		variables.assertThrows = function(required any callable, string exceptionType = "", string message = "") {
			variables._assertions.assertThrows(argumentCollection=arguments);
		};
		variables.assertCount = function(required numeric expected, required any collection, string message = "") {
			variables._assertions.assertCount(argumentCollection=arguments);
		};
		variables.assertContains = function(required any needle, required any haystack, string message = "") {
			variables._assertions.assertContains(argumentCollection=arguments);
		};
		variables.assertNotContains = function(required any needle, required any haystack, string message = "") {
			variables._assertions.assertNotContains(argumentCollection=arguments);
		};
		variables.assertMatches = function(required string pattern, required string string, string message = "") {
			variables._assertions.assertMatches(argumentCollection=arguments);
		};
		variables.assertEmpty = function(required any value, string message = "") {
			variables._assertions.assertEmpty(argumentCollection=arguments);
		};
		variables.assertNotEmpty = function(required any value, string message = "") {
			variables._assertions.assertNotEmpty(argumentCollection=arguments);
		};
		variables.assertInstanceOf = function(required string expected, required any actual, string message = "") {
			variables._assertions.assertInstanceOf(argumentCollection=arguments);
		};
		variables.assertGreaterThan = function(required numeric expected, required numeric actual, string message = "") {
			variables._assertions.assertGreaterThan(argumentCollection=arguments);
		};
		variables.assertLessThan = function(required numeric expected, required numeric actual, string message = "") {
			variables._assertions.assertLessThan(argumentCollection=arguments);
		};

		// Database assertion delegation methods
		variables.assertDatabaseHas = function(required string table, required struct attributes, string message = "") {
			variables._assertions.assertDatabaseHas(argumentCollection=arguments);
		};
		variables.assertDatabaseMissing = function(required string table, required struct attributes, string message = "") {
			variables._assertions.assertDatabaseMissing(argumentCollection=arguments);
		};
		variables.assertDatabaseCount = function(required string table, required numeric count, string message = "") {
			variables._assertions.assertDatabaseCount(argumentCollection=arguments);
		};

		// Expose to this scope as well
		this.assertEqual = variables.assertEqual;
		this.assertNotEqual = variables.assertNotEqual;
		this.assertTrue = variables.assertTrue;
		this.assertFalse = variables.assertFalse;
		this.assertNull = variables.assertNull;
		this.assertNotNull = variables.assertNotNull;
		this.assertThrows = variables.assertThrows;
		this.assertCount = variables.assertCount;
		this.assertContains = variables.assertContains;
		this.assertNotContains = variables.assertNotContains;
		this.assertMatches = variables.assertMatches;
		this.assertEmpty = variables.assertEmpty;
		this.assertNotEmpty = variables.assertNotEmpty;
		this.assertInstanceOf = variables.assertInstanceOf;
		this.assertGreaterThan = variables.assertGreaterThan;
		this.assertLessThan = variables.assertLessThan;

		// Expose database assertions to this scope
		this.assertDatabaseHas = variables.assertDatabaseHas;
		this.assertDatabaseMissing = variables.assertDatabaseMissing;
		this.assertDatabaseCount = variables.assertDatabaseCount;
	}

	/**
	 * Mix in factory helper methods
	 *
	 * Stores Factory instance and delegates factory calls to it.
	 * Provides make() and create() methods for test data generation.
	 */
	private void function mixinFactoryHelpers() {
		// Store factory instance for delegation
		variables._factory = new fuse.testing.Factory();

		// Create delegation methods for factory operations
		variables.make = function(required string factoryName, struct attributes = {}, array traits = []) {
			return variables._factory.make(argumentCollection=arguments);
		};
		variables.create = function(required string factoryName, struct attributes = {}, array traits = []) {
			return variables._factory.create(argumentCollection=arguments);
		};

		// Expose to this scope as well
		this.make = variables.make;
		this.create = variables.create;
	}

	/**
	 * Mix in handler testing helper methods
	 *
	 * Stores RequestHelper and ResponseHelper instances and provides
	 * makeRequest() and handle() methods for testing handlers.
	 */
	private void function mixinHandlerHelpers() {
		// Store helper instances for delegation
		variables._requestHelper = new fuse.testing.RequestHelper();
		variables._responseHelper = new fuse.testing.ResponseHelper();

		// Create delegation method for makeRequest
		variables.makeRequest = function(
			required string method,
			required string path,
			struct params = {},
			struct headers = {}
		) {
			return variables._requestHelper.makeRequest(argumentCollection=arguments);
		};

		// Create handle method that executes request through router
		variables.handle = function(required struct request) {
			// Get router from application scope or create new instance
			var router = "";
			if (isDefined("application.fuse.router") && isObject(application.fuse.router)) {
				router = application.fuse.router;
			} else {
				// No router available - throw descriptive error
				throw(
					type = "RouterNotFoundException",
					message = "No router available for handler testing",
					detail = "Set application.fuse.router or manually set variables.router in your test setup()"
				);
			}

			// Find matching route
			var routeMatch = router.findRoute(
				arguments.request.cgi.path_info,
				arguments.request.cgi.request_method
			);

			if (!routeMatch.matched) {
				// Return 404 response for no route match
				return variables._responseHelper.buildResponse(404, {}, "Not Found");
			}

			// Extract handler and method from route
			var handlerParts = listToArray(routeMatch.route.handler, ".");
			var handlerName = handlerParts[1];
			var methodName = handlerParts[2];

			// Instantiate handler
			var handlerPath = "app.handlers." & handlerName;
			try {
				var handler = createObject("component", handlerPath);
			} catch (any e) {
				// Handler not found - return 500 error
				return variables._responseHelper.buildResponse(500, {}, "Handler not found: " & handlerPath);
			}

			// Execute handler method with params
			var params = routeMatch.params;
			structAppend(params, arguments.request.url, false);
			structAppend(params, arguments.request.form, false);

			try {
				var handlerResult = invoke(handler, methodName, {params: params, request: arguments.request});

				// Extract response from handler result
				return variables._responseHelper.extractResponse(handlerResult);
			} catch (any e) {
				// Handler execution error - return 500 error
				return variables._responseHelper.buildResponse(500, {}, e.message);
			}
		};

		// Expose to this scope as well
		this.makeRequest = variables.makeRequest;
		this.handle = variables.handle;
	}

}
